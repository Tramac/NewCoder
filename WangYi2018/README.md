网易2018编程题
----
#### 1.魔法币
* 题目：<br>
小易准备去魔法王国采购魔法神器,购买魔法神器需要使用魔法币,但是小易现在一枚魔法币都没有,但是小易有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>
魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>
魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>
小易采购魔法神器总共需要n个魔法币,所以小易只能通过两台魔法机器产生恰好n个魔法币,小易需要你帮他设计一个投入方案使他最后恰好拥有n个魔法币。 <br>
* 输入描述:<br>
输入包括一行,包括一个正整数n(1 ≤ n ≤ 10^9),表示小易需要的魔法币数量。<br>
* 输出描述:<br>
输出一个字符串,每个字符表示该次小易选取投入的魔法机器。其中只包含字符'1'和'2'。<br>
* 我的思路：一个机器只能产生奇数，另一个只能产生偶数，从多到少选择就行了。对于输出，我是选择用栈保存的结果，看了一下别人的有用字符串的，最后将字符串反转一下也很方便。
* [我的代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/MagicCoin.cpp)<br>
#### 2.相反数
* 题目：<br>
为了得到一个数的"相反数",我们将这个数的数字顺序颠倒,然后再加上原先的数得到"相反数"。例如,为了得到1325的"相反数",首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. 
* 输入描述:<br>
输入包括一个整数n,(1 ≤ n ≤ 10^5)
* 输出描述:<br>
输出一个整数,表示n的相反数<br>
* 我的思路：<br>
输入的数字首先以字符串的格式读入，然后对字符串反转，再用一个从字符串到数字的转换函数。其实感觉挺麻烦的。Python的写法应该很简单，因为可以直接类型转换，就不多说了。<br>
* [我的代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/OppsiteNumber.cpp)
* 更新：<br>
或许直接将数字反转也可以，反转方法添加到了代码中（注释部分）。<br>
#### 3.字符串碎片
* 题目：<br>
一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,"aaabbaaac"是由下面碎片组成的:'aaa','bb','c'。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。<br>
* 输入描述:<br>
输入包括一个字符串s,字符串s的长度length(1 ≤ length ≤ 50),s只含小写字母('a'-'z')<br>
* 输出描述:<br>
输出一个整数,表示所有碎片的平均长度,四舍五入保留两位小数。<br>
* 我的思路：<br>
主要问题就是求这个字符串中有几个碎片，然后用总长度除以碎片个数就行了。主要要保留两位小数，所以我只能用printf输出了，cout应该也可以。
* [我的代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/StringPieces.cpp)<br>
#### 4.游历魔法王国
* 题目：<br>
魔法王国一共有n个城市,编号为0~n-1号,n个城市之间的道路连接起来恰好构成一棵树。<br>
小易现在在0号城市,每次行动小易会从当前所在的城市走到与其相邻的一个城市,小易最多能行动L次。<br>
如果小易到达过某个城市就视为小易游历过这个城市了,小易现在要制定好的旅游计划使他能游历最多的城市,请你帮他计算一下他最多能游历过多少个城市(注意0号城市已经游历了,游历过的城市不重复计算)。 <br>
* 输入描述:<br>
输入包括两行,第一行包括两个正整数n(2 ≤ n ≤ 50)和L(1 ≤ L ≤ 100),表示城市个数和小易能行动的次数。<br>
第二行包括n-1个整数parent[i](0 ≤ parent[i] ≤ i), 对于每个合法的i(0 ≤ i ≤ n - 2),在(i+1)号城市和parent[i]间有一条道路连接。<br>
* 输出描述:<br>
输出一个整数,表示小易最多能游历的城市数量。<br>
* 我的思路：<br>
这道题连读都没读懂。。。感觉描述有些问题。对于输入第二行，说0 ≤ i ≤ n - 2，这里的i指的应该是城市号吧,因为后面说（i+1）号城市。但是第二行只有n-1个数啊，如果i是从零开始的，那n-1号城市去哪儿了？所以，是不是应该是1<=i<=n-1呢？这样只是没有0号城市的父节点，因为它是根节点。<br>
这道题自己是在是做不出来，看别人的代码也有些不理解。<br>
这是一个贪心算法，要看一下贪心算法啊。<br>
注意虽然题目中说这是一个树结构，但是不是用树结构解决的，只是建模是树。仍然用数组解决。<br>
动态规划(dp)和贪心算法要加强啊，总结一下分别都适用于那些情况。<br>
还有，如果不需要对结构做更改，尽量使用引用或者指针吧，可以减少内存开支。<br>
* [别人代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/MostVisited.cpp)
#### 5.重排序列
* 题目：<br>
小易有一个长度为N的正整数数列A = {A[1], A[2], A[3]..., A[N]}。<br>
牛博士给小易出了一个难题:<br>
对数列A进行重新排列,使数列A满足所有的A[i] * A[i + 1](1 ≤ i ≤ N - 1)都是4的倍数。<br>
小易现在需要判断一个数列是否可以重排之后满足牛博士的要求。 <br>
* 输入描述:<br>
输入的第一行为数列的个数t(1 ≤ t ≤ 10),<br>
接下来每两行描述一个数列A,第一行为数列长度n(1 ≤ n ≤ 10^5)<br>
第二行为n个正整数A[i](1 ≤ A[i] ≤ 10^9)<br>
* 输出描述:<br>
对于每个数列输出一行表示是否可以满足牛博士要求,如果可以输出Yes,否则输出No。<br>
* 我的思路：<br>
没思路，没想到。唉。<br>
* 别人的思路：<br>
寻找可以被4和不可以被2整除的数的个数<br>
一个不可以被4和2整除的数周围必须有2个可以被4整除的数，除了第一个<br>
那么对于每一个n1都必须有一个属于它的n4，如果没有n2，那第一个n1可以和第2个共有一个<br>
所以就是 n4>=n1||(n2==0&&n4>=n1-1)<br>
* [别人的代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/RerrangeSequence.cpp)
#### 6.最长公共子括号序列
* 题目：<br>
一个合法的括号匹配序列被定义为:<br>
1. 空串""是合法的括号序列<br>
2. 如果"X"和"Y"是合法的序列,那么"XY"也是一个合法的括号序列<br>
3. 如果"X"是一个合法的序列,那么"(X)"也是一个合法的括号序列<br>
4. 每个合法的括号序列都可以由上面的规则生成<br>
例如"", "()", "()()()", "(()())", "(((()))"都是合法的。<br>
从一个字符串S中移除零个或者多个字符得到的序列称为S的子序列。<br>
例如"abcde"的子序列有"abe","","abcde"等。<br>
定义LCS(S,T)为字符串S和字符串T最长公共子序列的长度,即一个最长的序列W既是S的子序列也是T的子序列的长度。<br>
小易给出一个合法的括号匹配序列s,小易希望你能找出具有以下特征的括号序列t:<br>
1、t跟s不同,但是长度相同<br>
2、t也是一个合法的括号匹配序列<br>
3、LCS(s, t)是满足上述两个条件的t中最大的<br>
因为这样的t可能存在多个,小易需要你计算出满足条件的t有多少个。<br>
如样例所示: s = "(())()",跟字符串s长度相同的合法括号匹配序列有:<br>
"()(())", "((()))", "()()()", "(()())",其中LCS( "(())()", "()(())" )为4,其他三个都为5,所以输出3. <br>
* 输入描述:<br>
输入包括字符串s(4 ≤ |s| ≤ 50,|s|表示字符串长度),保证s是一个合法的括号匹配序列。<br>
* 输出描述:<br>
输出一个正整数,满足条件的t的个数。<br>
* 我的思路：<br>
还是没有想到。。。太笨了。。。只想到了如何判断是否合法。这里就说一下别人的思路吧。<br>
根据题意，要想使得 LCS 最大，删去任意一个字符即可获得 LCS = |s| - 1 ，再把该字符插到与原来不同的任意位置可以维持原长度，而不影响 LCS 的计算（可是选择删除哪个呢？删除不同的会有不同的情况吧。而且虽然插得位置不一样但是还有有可能和原字符串相同吧。删除操作该如何实现呢？插入操作又该怎样实现呢？）。<br>
* 上面问题的解决：<br>
关于担心插入之后的有重复的怎么办？用set啊，set容器可以去除重复元素，记住啊，灵活运用啊。以后一扯到重复就要想到set行不行。<br>
关于怎么删除，怎么插入？字符串中有指定删除某位置的字符，也有指定插入到某位置一个字符。记住啊。s.erase(),s.insert().<br>
因此最暴力的做法是枚举每个字符，把它插入到任意位置，判合法，去重，累计。<br>
优化 1 ：插入是插到指定位置的字符之前，如果插入的字符和该位置的字符相同，则插入后还是原字符串，可以跳过这种情况。否则最后的结果要 - 1 （如何跳过原位置？）。<br>
优化 2 ：左右两边一定是左右括号，不用移动它们。但字符却可以插到它们的后面。<br>
判合法：实际上就是括号匹配的平衡性。在这里，如果我们从前到后遍历，左括号可以暂时多于右括号，但不可以少于，因为能够闭合右括号的左括号都在左边了。每次成功闭合一对括号把数量 - 1 ，得到负数说明不平衡。<br>
* 总结：<br>
我在实现别人的算法的时候，总是提示超内存，所以以后要尽量避免不必要的内存开支。还有如果不能改变的参数要声明为const，注意中间变量。<br>
* [别人的代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/LongestCommonSequence.cpp)
#### 7.合唱
* 题目： <br>
小Q和牛博士合唱一首歌曲,这首歌曲由n个音调组成,每个音调由一个正整数表示。<br>
对于每个音调要么由小Q演唱要么由牛博士演唱,对于一系列音调演唱的难度等于所有相邻音调变化幅度之和, 例如一个音调序列是8, 8, 13, 12, 那么它的难度等于|8 - 8| + |13 - 8| + |12 - 13| = 6(其中||表示绝对值)。<br>
现在要对把这n个音调分配给小Q或牛博士,让他们演唱的难度之和最小,请你算算最小的难度和是多少。<br>
如样例所示: 小Q选择演唱{5, 6}难度为1, 牛博士选择演唱{1, 2, 1}难度为2,难度之和为3,这一个是最小难度和的方案了。 <br>
* 输入描述:<br>
输入包括两行,第一行一个正整数n(1 ≤ n ≤ 2000) 第二行n个整数v[i](1 ≤ v[i] ≤ 10^6), 表示每个音调。<br>
* 输出描述:<br>
输出一个整数,表示小Q和牛博士演唱最小的难度和是多少。<br>
* 我的思路：<br>
我没有思路，我连看着别人的思路都写不出来，搞不懂。动态规划啊，不想说了。比着写代码都调试不通。直接贴比人的代码吧。<br>
* [别人的代码](https://github.com/Tramac/NewCoder/blob/master/WangYi2018/Chorus.cpp)
