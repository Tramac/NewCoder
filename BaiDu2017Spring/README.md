百度2017春编程题
----
#### 1.买帽子
* 题目：<br>
度度熊想去商场买一顶帽子，商场里有N顶帽子，有些帽子的价格可能相同。度度熊想买一顶价格第三便宜的帽子，问第三便宜的帽子价格是多少？
* 我的思路：思路其实挺简单的吧，主要是想到容器set的使用，注意set是自动从小到大排序的，并且不能通过索引返回，注意auto的使用以及返回值方法，看代码。
* [我的代码](https://github.com/Tramac/NewCoder/blob/master/BaiDu2017Spring/BuyCaps.cpp)
#### 2.度度熊回家
* 题目：
一个数轴上共有N个点，第一个点的坐标是度度熊现在位置，第N-1个点是度度熊的家。现在他需要依次的从0号坐标走到N-1号坐标。
但是除了0号坐标和N-1号坐标，他可以在其余的N-2个坐标中选出一个点，并直接将这个点忽略掉，问度度熊回家至少走多少距离？
* 我的思路：思路比较简单，对于一个地点，需要计算出去掉该点可以节省的距离以及上一点到下一点增加的距离。用减少的距离减去增加的距离就是最终可以省略的路程。遍历找出最大省略的路程，再用总路程减去该路程就行了。
* [我的代码](https://github.com/Tramac/NewCoder/blob/master/BaiDu2017Spring/GoHome.cpp)
#### 3.寻找三角形
* 题目：三维空间中有N个点，每个点可能是三种颜色的其中之一，三种颜色分别是红绿蓝，分别用'R', 'G', 'B'表示。 
现在要找出三个点，并组成一个三角形，使得这个三角形的面积最大。
但是三角形必须满足：三个点的颜色要么全部相同，要么全部不同。
* 我的思路：直接说是个数学题好了。注意的地方，记得会定义结构体以存储这种数据的输入，海伦公式。保留小数的输出方法。精度不知道哪里出问题了，一直不能AC。
* [我的代码](https://github.com/Tramac/NewCoder/blob/master/BaiDu2017Spring/FindAngel.cpp)
#### 4.有趣的排序
* 题目：度度熊有一个N个数的数组，他想将数组从小到大 排好序，但是萌萌的度度熊只会下面这个操作：
任取数组中的一个数然后将它放置在数组的最后一个位置。
问最少操作多少次可以使得数组从小到大有序？ 
* 我的思路：寻找给出的序列中从最小的数开始的最长已排序个数就行了。但是没有想到解决方法。
* [代码](https://github.com/Tramac/NewCoder/blob/master/BaiDu2017Spring/IntrestingSort.cpp)
#### 5.不等式数列
* 题目：度度熊最近对全排列特别感兴趣,对于1到n的一个排列,度度熊发现可以在中间根据大小关系插入合适的大于和小于符号(即 '>' 和 '<' )使其成为一个合法的不等式数列。但是现在度度熊手中只有k个小于符号即('<'')和n-k-1个大于符号(即'>'),度度熊想知道对于1至n任意的排列中有多少个排列可以使用这些符号使其为合法的不等式数列。 
* 我的思路：动态规划的题还是搞不定。直接贴出别人的思路吧。<br>
dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1)) % 2017;<br>
dp[i][j]表示有i个数字及j个小于号所能组成的数量(大于号数量当然是i - j - 1次，后面需要使用)<br>
而加入第i + 1个数字时，分以下四种情况：<br>
1.如果将i+1插入当前序列的开头，即有了1<2，加入后成为3>1<2，会发现等于同时加入了一个大于号！(此时可以无视1与2之间的关系，因为i+1>i)<br>
2.如果将i+1插入当前序列末尾,即1<2变成了 1<2<3，会发现等于同时加入了一个小于号！ (此时可以无视1与2之间的关系，因为i+1>i)<br>
3.如果将i+1加入一个小于号之间，即已经有 1<2了，向中间加入3,会发现变成了1<3>2，等于同时加入了一个大于号！<br>
4.如果将i+1加入一个大于号中间，即有了2>1，变成了2<3>1，等于同时加入了一个小于号！<br>
综上所述，dp[i][j]等于以上四种情况之和：<br>
dp[i - 1][j] 将i加在开头等于加入一个大于号，即要求i-1个数时已经有了j个小于号<br>
dp[i - 1][j - 1] 将i加在末尾等于加入一个小于号，即要求i-1个数时已经有了j-1个小于号<br>
dp[i - 1][j] * j 将i加在任意一个小于号之间，等于加入了一个大于号；即要求i-1个数时已经有了j个小于号，每个小于号都可以进行这样的一次插入<br>
dp[i - 1][j - 1] * (i- j - 1) 将i加载任意一个大于号之间，等于加入了一个小于号；即要求i-1个数时有了j-1个小于号，而此时共有<br>
(i - 1) - (j - 1)- 1个大于号，每个大于号都要进行一次这样的操作合并同类项即为<br>
dp[i][j] = (dp[i - 1][j - 1] * (i - j) + dp[i - 1][j] * (j + 1))<br>
最后要记得取模<br>
* 实现代码的时候，动态规划数组要定义到主函数外，而且要注意最大值不能选小了，否则会溢出。
* [代码](https://github.com/Tramac/NewCoder/blob/master/BaiDu2017Spring/InequalitySequencecpp)
